; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt < %s -passes=instcombine -S | FileCheck %s

; FIXME: This is technically incorrect because it might overwrite a poison
; value. Stop folding it once #52930 is resolved.
define void @store_of_undef(ptr %P) {
; CHECK-LABEL: define void @store_of_undef(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    ret void
;
  store i32 undef, ptr %P
  ret void
}

define void @store_of_poison(ptr %P) {
; CHECK-LABEL: define void @store_of_poison(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    ret void
;
  store i32 poison, ptr %P
  ret void
}

define void @store_into_undef(ptr %P) {
; CHECK-LABEL: define void @store_into_undef(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    store i32 123, ptr undef, align 4
; CHECK-NEXT:    ret void
;
  store i32 123, ptr undef
  ret void
}

define void @store_into_null(ptr %P) {
; CHECK-LABEL: define void @store_into_null(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    store i32 poison, ptr null, align 4
; CHECK-NEXT:    ret void
;
  store i32 124, ptr null
  ret void
}

define void @test2(ptr %P) {
; CHECK-LABEL: define void @test2(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    ret void
;
  %X = load i32, ptr %P
  %Y = add i32 %X, 0
  store i32 %Y, ptr %P
  ret void
}

define void @store_at_gep_off_null_inbounds(i64 %offset) {
; CHECK-LABEL: define void @store_at_gep_off_null_inbounds(
; CHECK-SAME: i64 [[OFFSET:%.*]]) {
; CHECK-NEXT:    [[PTR:%.*]] = getelementptr inbounds i32, ptr null, i64 [[OFFSET]]
; CHECK-NEXT:    store i32 poison, ptr [[PTR]], align 4
; CHECK-NEXT:    ret void
;
  %ptr = getelementptr inbounds i32, ptr null, i64 %offset
  store i32 24, ptr %ptr
  ret void
}

define void @store_at_gep_off_null_not_inbounds(i64 %offset) {
; CHECK-LABEL: define void @store_at_gep_off_null_not_inbounds(
; CHECK-SAME: i64 [[OFFSET:%.*]]) {
; CHECK-NEXT:    [[PTR:%.*]] = getelementptr i32, ptr null, i64 [[OFFSET]]
; CHECK-NEXT:    store i32 poison, ptr [[PTR]], align 4
; CHECK-NEXT:    ret void
;
  %ptr = getelementptr i32, ptr null, i64 %offset
  store i32 24, ptr %ptr
  ret void
}

define void @store_at_gep_off_no_null_opt(i64 %offset) #0 {
; CHECK-LABEL: define void @store_at_gep_off_no_null_opt(
; CHECK-SAME: i64 [[OFFSET:%.*]]) #[[ATTR0:[0-9]+]] {
; CHECK-NEXT:    [[PTR:%.*]] = getelementptr inbounds i32, ptr null, i64 [[OFFSET]]
; CHECK-NEXT:    store i32 24, ptr [[PTR]], align 4
; CHECK-NEXT:    ret void
;
  %ptr = getelementptr inbounds i32, ptr null, i64 %offset
  store i32 24, ptr %ptr
  ret void
}

attributes #0 = { null_pointer_is_valid }

;; Simple sinking tests

; "if then else"
define i32 @test3(i1 %C) {
; CHECK-LABEL: define i32 @test3(
; CHECK-SAME: i1 [[C:%.*]]) {
; CHECK-NEXT:    br i1 [[C]], label %[[COND:.*]], label %[[COND2:.*]]
; CHECK:       [[COND]]:
; CHECK-NEXT:    br label %[[CONT:.*]]
; CHECK:       [[COND2]]:
; CHECK-NEXT:    br label %[[CONT]]
; CHECK:       [[CONT]]:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i32 [ 47, %[[COND2]] ], [ -987654321, %[[COND]] ]
; CHECK-NEXT:    ret i32 [[STOREMERGE]]
;
  %A = alloca i32
  br i1 %C, label %Cond, label %Cond2

Cond:
  store i32 -987654321, ptr %A
  br label %Cont

Cond2:
  store i32 47, ptr %A
  br label %Cont

Cont:
  %V = load i32, ptr %A
  ret i32 %V
}

; "if then"
define i32 @test4(i1 %C) {
; CHECK-LABEL: define i32 @test4(
; CHECK-SAME: i1 [[C:%.*]]) {
; CHECK-NEXT:    br i1 [[C]], label %[[COND:.*]], label %[[CONT:.*]]
; CHECK:       [[COND]]:
; CHECK-NEXT:    br label %[[CONT]]
; CHECK:       [[CONT]]:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i32 [ -987654321, %[[COND]] ], [ 47, [[TMP0:%.*]] ]
; CHECK-NEXT:    ret i32 [[STOREMERGE]]
;
  %A = alloca i32
  store i32 47, ptr %A
  br i1 %C, label %Cond, label %Cont

Cond:
  store i32 -987654321, ptr %A
  br label %Cont

Cont:
  %V = load i32, ptr %A
  ret i32 %V
}

; "if then"
define void @test5(i1 %C, ptr %P) {
; CHECK-LABEL: define void @test5(
; CHECK-SAME: i1 [[C:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:    br i1 [[C]], label %[[COND:.*]], label %[[CONT:.*]]
; CHECK:       [[COND]]:
; CHECK-NEXT:    br label %[[CONT]]
; CHECK:       [[CONT]]:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i32 [ -987654321, %[[COND]] ], [ 47, [[TMP0:%.*]] ]
; CHECK-NEXT:    store i32 [[STOREMERGE]], ptr [[P]], align 1
; CHECK-NEXT:    ret void
;
  store i32 47, ptr %P, align 1
  br i1 %C, label %Cond, label %Cont

Cond:
  store i32 -987654321, ptr %P, align 1
  br label %Cont

Cont:
  ret void
}


; PR14753 - merging two stores should preserve the TBAA tag.
define void @test6(i32 %n, ptr %a, ptr %gi) nounwind uwtable ssp {
; CHECK-LABEL: define void @test6(
; CHECK-SAME: i32 [[N:%.*]], ptr [[A:%.*]], ptr [[GI:%.*]]) #[[ATTR1:[0-9]+]] {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    br label %[[FOR_COND:.*]]
; CHECK:       [[FOR_COND]]:
; CHECK-NEXT:    [[STOREMERGE:%.*]] = phi i32 [ 42, %[[ENTRY]] ], [ [[INC:%.*]], %[[FOR_BODY:.*]] ]
; CHECK-NEXT:    store i32 [[STOREMERGE]], ptr [[GI]], align 4, !tbaa [[INT_TBAA0:![0-9]+]]
; CHECK-NEXT:    [[CMP:%.*]] = icmp slt i32 [[STOREMERGE]], [[N]]
; CHECK-NEXT:    br i1 [[CMP]], label %[[FOR_BODY]], label %[[FOR_END:.*]]
; CHECK:       [[FOR_BODY]]:
; CHECK-NEXT:    [[IDXPROM:%.*]] = sext i32 [[STOREMERGE]] to i64
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds float, ptr [[A]], i64 [[IDXPROM]]
; CHECK-NEXT:    store float 0.000000e+00, ptr [[ARRAYIDX]], align 4, !tbaa [[FLOAT_TBAA4:![0-9]+]]
; CHECK-NEXT:    [[TMP0:%.*]] = load i32, ptr [[GI]], align 4, !tbaa [[INT_TBAA0]]
; CHECK-NEXT:    [[INC]] = add nsw i32 [[TMP0]], 1
; CHECK-NEXT:    br label %[[FOR_COND]]
; CHECK:       [[FOR_END]]:
; CHECK-NEXT:    ret void
;
entry:
  store i32 42, ptr %gi, align 4, !tbaa !0
  br label %for.cond

for.cond:
  %storemerge = phi i32 [ 0, %entry ], [ %inc, %for.body ]
  %0 = load i32, ptr %gi, align 4, !tbaa !0
  %cmp = icmp slt i32 %0, %n
  br i1 %cmp, label %for.body, label %for.end

for.body:
  %idxprom = sext i32 %0 to i64
  %arrayidx = getelementptr inbounds float, ptr %a, i64 %idxprom
  store float 0.000000e+00, ptr %arrayidx, align 4, !tbaa !3
  %1 = load i32, ptr %gi, align 4, !tbaa !0
  %inc = add nsw i32 %1, 1
  store i32 %inc, ptr %gi, align 4, !tbaa !0
  br label %for.cond

for.end:
  ret void
}

define void @dse1(ptr %p) {
; CHECK-LABEL: define void @dse1(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    store i32 0, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  store i32 0, ptr %p
  store i32 0, ptr %p
  ret void
}

; Slightly subtle: if we're mixing atomic and non-atomic access to the
; same location, then the contents of the location are undefined if there's
; an actual race.  As such, we're free to pick either store under the
; assumption that we're not racing with any other thread.
define void @dse2(ptr %p) {
; CHECK-LABEL: define void @dse2(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    store i32 0, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  store atomic i32 0, ptr %p unordered, align 4
  store i32 0, ptr %p
  ret void
}

define void @dse3(ptr %p) {
; CHECK-LABEL: define void @dse3(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    store atomic i32 0, ptr [[P]] unordered, align 4
; CHECK-NEXT:    ret void
;
  store i32 0, ptr %p
  store atomic i32 0, ptr %p unordered, align 4
  ret void
}

define void @dse4(ptr %p) {
; CHECK-LABEL: define void @dse4(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    store atomic i32 0, ptr [[P]] unordered, align 4
; CHECK-NEXT:    ret void
;
  store atomic i32 0, ptr %p unordered, align 4
  store atomic i32 0, ptr %p unordered, align 4
  ret void
}

; Implementation limit - could remove unordered store here, but
; currently don't.
define void @dse5(ptr %p) {
; CHECK-LABEL: define void @dse5(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    store atomic i32 0, ptr [[P]] unordered, align 4
; CHECK-NEXT:    store atomic i32 0, ptr [[P]] seq_cst, align 4
; CHECK-NEXT:    ret void
;
  store atomic i32 0, ptr %p unordered, align 4
  store atomic i32 0, ptr %p seq_cst, align 4
  ret void
}

define void @write_back1(ptr %p) {
; CHECK-LABEL: define void @write_back1(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    ret void
;
  %v = load i32, ptr %p
  store i32 %v, ptr %p
  ret void
}

define void @write_back2(ptr %p) {
; CHECK-LABEL: define void @write_back2(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    ret void
;
  %v = load atomic i32, ptr %p unordered, align 4
  store i32 %v, ptr %p
  ret void
}

define void @write_back3(ptr %p) {
; CHECK-LABEL: define void @write_back3(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    ret void
;
  %v = load i32, ptr %p
  store atomic i32 %v, ptr %p unordered, align 4
  ret void
}

define void @write_back4(ptr %p) {
; CHECK-LABEL: define void @write_back4(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    ret void
;
  %v = load atomic i32, ptr %p unordered, align 4
  store atomic i32 %v, ptr %p unordered, align 4
  ret void
}

; Can't remove store due to ordering side effect
define void @write_back5(ptr %p) {
; CHECK-LABEL: define void @write_back5(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[V:%.*]] = load atomic i32, ptr [[P]] unordered, align 4
; CHECK-NEXT:    store atomic i32 [[V]], ptr [[P]] seq_cst, align 4
; CHECK-NEXT:    ret void
;
  %v = load atomic i32, ptr %p unordered, align 4
  store atomic i32 %v, ptr %p seq_cst, align 4
  ret void
}

define void @write_back6(ptr %p) {
; CHECK-LABEL: define void @write_back6(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[V:%.*]] = load atomic i32, ptr [[P]] seq_cst, align 4
; CHECK-NEXT:    ret void
;
  %v = load atomic i32, ptr %p seq_cst, align 4
  store atomic i32 %v, ptr %p unordered, align 4
  ret void
}

define void @write_back7(ptr %p) {
; CHECK-LABEL: define void @write_back7(
; CHECK-SAME: ptr [[P:%.*]]) {
; CHECK-NEXT:    [[V:%.*]] = load atomic volatile i32, ptr [[P]] seq_cst, align 4
; CHECK-NEXT:    ret void
;
  %v = load atomic volatile i32, ptr %p seq_cst, align 4
  store atomic i32 %v, ptr %p unordered, align 4
  ret void
}

@Unknown = external constant i32

define void @store_to_constant() {
; CHECK-LABEL: define void @store_to_constant() {
; CHECK-NEXT:    ret void
;
  store i32 0, ptr @Unknown
  ret void
}

; Delete stores to readonly noalias pointers.
define void @store_to_readonly_noalias(ptr readonly noalias %0) {
; CHECK-LABEL: define void @store_to_readonly_noalias(
; CHECK-SAME: ptr noalias readonly [[TMP0:%.*]]) {
; CHECK-NEXT:    ret void
;
  store i32 3, ptr %0, align 4
  ret void
}

define void @store_select_with_null(i1 %cond, ptr %p) {
; CHECK-LABEL: define void @store_select_with_null(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:    store i32 0, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  %sel = select i1 %cond, ptr %p, ptr null
  store i32 0, ptr %sel, align 4
  ret void
}

define void @store_select_with_null_commuted(i1 %cond, ptr %p) {
; CHECK-LABEL: define void @store_select_with_null_commuted(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[P:%.*]]) {
; CHECK-NEXT:    store i32 0, ptr [[P]], align 4
; CHECK-NEXT:    ret void
;
  %sel = select i1 %cond, ptr null, ptr %p
  store i32 0, ptr %sel, align 4
  ret void
}

define void @store_select_with_null_null_is_valid(i1 %cond, ptr %p) null_pointer_is_valid {
; CHECK-LABEL: define void @store_select_with_null_null_is_valid(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[P:%.*]]) #[[ATTR0]] {
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[P]], ptr null
; CHECK-NEXT:    store i32 0, ptr [[SEL]], align 4
; CHECK-NEXT:    ret void
;
  %sel = select i1 %cond, ptr %p, ptr null
  store i32 0, ptr %sel, align 4
  ret void
}

define void @store_select_with_unknown(i1 %cond, ptr %p, ptr %p2) {
; CHECK-LABEL: define void @store_select_with_unknown(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[P:%.*]], ptr [[P2:%.*]]) {
; CHECK-NEXT:    [[SEL:%.*]] = select i1 [[COND]], ptr [[P]], ptr [[P2]]
; CHECK-NEXT:    store i32 0, ptr [[SEL]], align 4
; CHECK-NEXT:    ret void
;
  %sel = select i1 %cond, ptr %p, ptr %p2
  store i32 0, ptr %sel, align 4
  ret void
}

define void @store_select_with_null_gep(i1 %cond, ptr %p, i64 %off) {
; CHECK-LABEL: define void @store_select_with_null_gep(
; CHECK-SAME: i1 [[COND:%.*]], ptr [[P:%.*]], i64 [[OFF:%.*]]) {
; CHECK-NEXT:    [[GEP:%.*]] = getelementptr i8, ptr [[P]], i64 [[OFF]]
; CHECK-NEXT:    store i32 0, ptr [[GEP]], align 4
; CHECK-NEXT:    ret void
;
  %sel = select i1 %cond, ptr %p, ptr null
  %gep = getelementptr i8, ptr %sel, i64 %off
  store i32 0, ptr %gep, align 4
  ret void
}

!0 = !{!4, !4, i64 0}
!1 = !{!"omnipotent char", !2}
!2 = !{!"Simple C/C++ TBAA"}
!3 = !{!"float", !1}
!4 = !{!"int", !1}
;.
; CHECK: [[INT_TBAA0]] = !{[[META1:![0-9]+]], [[META1]], i64 0}
; CHECK: [[META1]] = !{!"int", [[META2:![0-9]+]]}
; CHECK: [[META2]] = !{!"omnipotent char", [[META3:![0-9]+]]}
; CHECK: [[META3]] = !{!"Simple C/C++ TBAA"}
; CHECK: [[FLOAT_TBAA4]] = !{[[META5:![0-9]+]], [[META5]], i64 0}
; CHECK: [[META5]] = !{!"float", [[META2]]}
;.
