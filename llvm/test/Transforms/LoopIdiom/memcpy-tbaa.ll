; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 6
; RUN: opt -passes="loop-idiom" < %s -S | FileCheck %s

define void @looper(ptr noalias nocapture readonly %M, ptr noalias nocapture %out) {
; CHECK-LABEL: define void @looper(
; CHECK-SAME: ptr noalias readonly captures(none) [[M:%.*]], ptr noalias captures(none) [[OUT:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[OUT]], ptr align 8 [[M]], i64 256, i1 false), !tbaa [[TBAA0:![0-9]+]]
; CHECK-NEXT:    br label %[[FOR_BODY4:.*]]
; CHECK:       [[FOR_BODY4]]:
; CHECK-NEXT:    [[J_020:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC:%.*]], %[[FOR_BODY4]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double, ptr [[M]], i64 [[J_020]]
; CHECK-NEXT:    [[A0:%.*]] = load double, ptr [[ARRAYIDX]], align 8, !tbaa [[TBAA0]]
; CHECK-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds double, ptr [[OUT]], i64 [[J_020]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i64 [[J_020]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i64 [[J_020]], 31
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY4]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.body4

for.body4:                                        ; preds = %for.cond1.preheader, %for.body4
  %j.020 = phi i64 [ 0, %entry ], [ %inc, %for.body4 ]
  %arrayidx = getelementptr inbounds double, ptr %M, i64 %j.020
  %a0 = load double, ptr %arrayidx, align 8, !tbaa !5
  %arrayidx8 = getelementptr inbounds double, ptr %out, i64 %j.020
  store double %a0, ptr %arrayidx8, align 8, !tbaa !5
  %inc = add nuw nsw i64 %j.020, 1
  %cmp2 = icmp ult i64 %j.020, 31
  br i1 %cmp2, label %for.body4, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3
  ret void
}


define void @looperBadMerge(ptr noalias nocapture readonly %M, ptr noalias nocapture %out) {
; CHECK-LABEL: define void @looperBadMerge(
; CHECK-SAME: ptr noalias readonly captures(none) [[M:%.*]], ptr noalias captures(none) [[OUT:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[OUT]], ptr align 8 [[M]], i64 256, i1 false), !tbaa [[TBAA4:![0-9]+]]
; CHECK-NEXT:    br label %[[FOR_BODY4:.*]]
; CHECK:       [[FOR_BODY4]]:
; CHECK-NEXT:    [[J_020:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC:%.*]], %[[FOR_BODY4]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double, ptr [[M]], i64 [[J_020]]
; CHECK-NEXT:    [[A0:%.*]] = load double, ptr [[ARRAYIDX]], align 8, !tbaa [[TBAA0]]
; CHECK-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds double, ptr [[OUT]], i64 [[J_020]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i64 [[J_020]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i64 [[J_020]], 31
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY4]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.body4

for.body4:                                        ; preds = %for.cond1.preheader, %for.body4
  %j.020 = phi i64 [ 0, %entry ], [ %inc, %for.body4 ]
  %arrayidx = getelementptr inbounds double, ptr %M, i64 %j.020
  %a0 = load double, ptr %arrayidx, align 8, !tbaa !5
  %arrayidx8 = getelementptr inbounds double, ptr %out, i64 %j.020
  store double %a0, ptr %arrayidx8, align 8, !tbaa !3
  %inc = add nuw nsw i64 %j.020, 1
  %cmp2 = icmp ult i64 %j.020, 31
  br i1 %cmp2, label %for.body4, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3
  ret void
}

define void @looperGoodMerge(ptr noalias nocapture readonly %M, ptr noalias nocapture %out) {
; CHECK-LABEL: define void @looperGoodMerge(
; CHECK-SAME: ptr noalias readonly captures(none) [[M:%.*]], ptr noalias captures(none) [[OUT:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[OUT]], ptr align 8 [[M]], i64 256, i1 false)
; CHECK-NEXT:    br label %[[FOR_BODY4:.*]]
; CHECK:       [[FOR_BODY4]]:
; CHECK-NEXT:    [[J_020:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC:%.*]], %[[FOR_BODY4]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double, ptr [[M]], i64 [[J_020]]
; CHECK-NEXT:    [[A0:%.*]] = load double, ptr [[ARRAYIDX]], align 8, !tbaa [[TBAA0]]
; CHECK-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds double, ptr [[OUT]], i64 [[J_020]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i64 [[J_020]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i64 [[J_020]], 31
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY4]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.body4

for.body4:                                        ; preds = %for.cond1.preheader, %for.body4
  %j.020 = phi i64 [ 0, %entry ], [ %inc, %for.body4 ]
  %arrayidx = getelementptr inbounds double, ptr %M, i64 %j.020
  %a0 = load double, ptr %arrayidx, align 8, !tbaa !5
  %arrayidx8 = getelementptr inbounds double, ptr %out, i64 %j.020
  store double %a0, ptr %arrayidx8, align 8
  %inc = add nuw nsw i64 %j.020, 1
  %cmp2 = icmp ult i64 %j.020, 31
  br i1 %cmp2, label %for.body4, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3
  ret void
}

define void @looperConstantTBAAStruct(ptr nocapture noalias %out, ptr nocapture noalias %in) {
; CHECK-LABEL: define void @looperConstantTBAAStruct(
; CHECK-SAME: ptr noalias captures(none) [[OUT:%.*]], ptr noalias captures(none) [[IN:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[OUT]], ptr align 8 [[IN]], i64 32, i1 false), !tbaa [[TBAA5:![0-9]+]]
; CHECK-NEXT:    br label %[[FOR_BODY4:.*]]
; CHECK:       [[FOR_BODY4]]:
; CHECK-NEXT:    [[J_020:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC:%.*]], %[[FOR_BODY4]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double, ptr [[IN]], i64 [[J_020]]
; CHECK-NEXT:    [[A0:%.*]] = load double, ptr [[ARRAYIDX]], align 8, !tbaa [[TBAA9:![0-9]+]]
; CHECK-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds double, ptr [[OUT]], i64 [[J_020]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i64 [[J_020]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i64 [[J_020]], 3
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY4]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.body4

for.body4:                                        ; preds = %for.cond1.preheader, %for.body4
  %j.020 = phi i64 [ 0, %entry ], [ %inc, %for.body4 ]
  %arrayidx = getelementptr inbounds double, ptr %in, i64 %j.020
  %a0 = load double, ptr %arrayidx, align 8, !tbaa !10
  %arrayidx8 = getelementptr inbounds double, ptr %out, i64 %j.020
  store double %a0, ptr %arrayidx8, align 8, !tbaa !10
  %inc = add nuw nsw i64 %j.020, 1
  %cmp2 = icmp ult i64 %j.020, 3
  br i1 %cmp2, label %for.body4, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3
  ret void
}

define void @looperVarTBAAStruct(ptr nocapture noalias %out, ptr nocapture noalias %in, i64 %len) {
; CHECK-LABEL: define void @looperVarTBAAStruct(
; CHECK-SAME: ptr noalias captures(none) [[OUT:%.*]], ptr noalias captures(none) [[IN:%.*]], i64 [[LEN:%.*]]) {
; CHECK-NEXT:  [[ENTRY:.*]]:
; CHECK-NEXT:    [[UMAX:%.*]] = call i64 @llvm.umax.i64(i64 [[LEN]], i64 1)
; CHECK-NEXT:    [[TMP0:%.*]] = shl nuw i64 [[UMAX]], 3
; CHECK-NEXT:    call void @llvm.memcpy.p0.p0.i64(ptr align 8 [[OUT]], ptr align 8 [[IN]], i64 [[TMP0]], i1 false)
; CHECK-NEXT:    br label %[[FOR_BODY4:.*]]
; CHECK:       [[FOR_BODY4]]:
; CHECK-NEXT:    [[J_020:%.*]] = phi i64 [ 0, %[[ENTRY]] ], [ [[INC:%.*]], %[[FOR_BODY4]] ]
; CHECK-NEXT:    [[ARRAYIDX:%.*]] = getelementptr inbounds double, ptr [[IN]], i64 [[J_020]]
; CHECK-NEXT:    [[A0:%.*]] = load double, ptr [[ARRAYIDX]], align 8, !tbaa [[TBAA9]]
; CHECK-NEXT:    [[ARRAYIDX8:%.*]] = getelementptr inbounds double, ptr [[OUT]], i64 [[J_020]]
; CHECK-NEXT:    [[INC]] = add nuw nsw i64 [[J_020]], 1
; CHECK-NEXT:    [[CMP2:%.*]] = icmp ult i64 [[INC]], [[LEN]]
; CHECK-NEXT:    br i1 [[CMP2]], label %[[FOR_BODY4]], label %[[FOR_COND_CLEANUP:.*]]
; CHECK:       [[FOR_COND_CLEANUP]]:
; CHECK-NEXT:    ret void
;
entry:
  br label %for.body4

for.body4:                                        ; preds = %for.cond1.preheader, %for.body4
  %j.020 = phi i64 [ 0, %entry ], [ %inc, %for.body4 ]
  %arrayidx = getelementptr inbounds double, ptr %in, i64 %j.020
  %a0 = load double, ptr %arrayidx, align 8, !tbaa !10
  %arrayidx8 = getelementptr inbounds double, ptr %out, i64 %j.020
  store double %a0, ptr %arrayidx8, align 8, !tbaa !10
  %inc = add nuw nsw i64 %j.020, 1
  %cmp2 = icmp ult i64 %inc, %len
  br i1 %cmp2, label %for.body4, label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup3
  ret void
}




!3 = !{!4, !4, i64 0}
!4 = !{!"float", !7, i64 0}
!5 = !{!6, !6, i64 0}
!6 = !{!"double", !7, i64 0}
!7 = !{!"omnipotent char", !8, i64 0}
!8 = !{!"Simple C++ TBAA"}

!15 = !{!8, i64 0, !"omnipotent char"}
!17 = !{!15, i64 8, !"double"}
!9 = !{!15, i64 32, !"_ZTS1A", !17, i64 0, i64 8, !17, i64 8, i64 8, !17, i64 16, i64 8, !17, i64 24, i64 8}
!10 = !{!9, !17, i64 0, i64 8}
;.
; CHECK: [[TBAA0]] = !{[[META1:![0-9]+]], [[META1]], i64 0}
; CHECK: [[META1]] = !{!"double", [[META2:![0-9]+]], i64 0}
; CHECK: [[META2]] = !{!"omnipotent char", [[META3:![0-9]+]], i64 0}
; CHECK: [[META3]] = !{!"Simple C++ TBAA"}
; CHECK: [[TBAA4]] = !{[[META2]], [[META2]], i64 0}
; CHECK: [[TBAA5]] = !{[[META6:![0-9]+]], [[META8:![0-9]+]], i64 0, i64 32}
; CHECK: [[META6]] = !{[[META7:![0-9]+]], i64 32, !"_ZTS1A", [[META8]], i64 0, i64 8, [[META8]], i64 8, i64 8, [[META8]], i64 16, i64 8, [[META8]], i64 24, i64 8}
; CHECK: [[META7]] = !{[[META3]], i64 0, !"omnipotent char"}
; CHECK: [[META8]] = !{[[META7]], i64 8, !"double"}
; CHECK: [[TBAA9]] = !{[[META6]], [[META8]], i64 0, i64 8}
;.
